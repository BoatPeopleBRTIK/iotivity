diff -rupN /Ethernet/src/Ethernet.cpp /Ethernet/src/Ethernet.cpp
--- /Ethernet/src/Ethernet.cpp	2014-10-01 20:45:35.000000000 +0530
+++ /Ethernet/src/Ethernet.cpp	2014-12-12 16:39:26.000000000 +0530
@@ -7,10 +7,11 @@ uint8_t EthernetClass::_state[MAX_SOCK_N
   0, 0, 0, 0 };
 uint16_t EthernetClass::_server_port[MAX_SOCK_NUM] = { 
   0, 0, 0, 0 };
+static DhcpClass s_dhcp;
 
 int EthernetClass::begin(uint8_t *mac_address)
 {
-  static DhcpClass s_dhcp;
+  //static DhcpClass s_dhcp;
   _dhcp = &s_dhcp;
 
 
diff -rupN /Ethernet/src/utility/socket.cpp /Ethernet/src/utility/socket.cpp
--- /Ethernet/src/utility/socket.cpp	2014-10-01 20:45:35.000000000 +0530
+++ /Ethernet/src/utility/socket.cpp	2014-12-17 17:02:20.000000000 +0530
@@ -295,6 +295,7 @@ uint16_t recvfrom(SOCKET s, uint8_t *buf
 {
   uint8_t head[8];
   uint16_t data_len=0;
+  uint16_t data_copied=0;
   uint16_t ptr=0;
 
   if ( len > 0 )
@@ -316,10 +317,10 @@ uint16_t recvfrom(SOCKET s, uint8_t *buf
       data_len = head[6];
       data_len = (data_len << 8) + head[7];
 
-      W5100.read_data(s, ptr, buf, data_len); // data copy.
-      ptr += data_len;
+      //W5100.read_data(s, ptr, buf, data_len); // data copy.
+      //ptr += data_len;
 
-      W5100.writeSnRX_RD(s, ptr);
+      //W5100.writeSnRX_RD(s, ptr);
       break;
 
     case SnMR::IPRAW :
@@ -333,10 +334,10 @@ uint16_t recvfrom(SOCKET s, uint8_t *buf
       data_len = head[4];
       data_len = (data_len << 8) + head[5];
 
-      W5100.read_data(s, ptr, buf, data_len); // data copy.
-      ptr += data_len;
+      //W5100.read_data(s, ptr, buf, data_len); // data copy.
+      //ptr += data_len;
 
-      W5100.writeSnRX_RD(s, ptr);
+      //W5100.writeSnRX_RD(s, ptr);
       break;
 
     case SnMR::MACRAW:
@@ -345,18 +346,25 @@ uint16_t recvfrom(SOCKET s, uint8_t *buf
       data_len = head[0];
       data_len = (data_len<<8) + head[1] - 2;
 
-      W5100.read_data(s, ptr, buf, data_len);
-      ptr += data_len;
-      W5100.writeSnRX_RD(s, ptr);
+      //W5100.read_data(s, ptr, buf, data_len);
+      //ptr += data_len;
+      //W5100.writeSnRX_RD(s, ptr);
       break;
 
     default :
       break;
     }
+	
+	if (data_len > 0)
+	{
+	    data_copied = (data_len <= len) ? data_len : len;// only copy the len bytes, rest of is discarded.
+		W5100.read_data(s, ptr, buf, data_copied); // data copy.
+		ptr += data_len;
+		W5100.writeSnRX_RD(s, ptr);
+	}
     W5100.execCmdSn(s, Sock_RECV);
-    SPI.endTransaction();
   }
-  return data_len;
+  return data_copied;
 }
 
 /**
diff -rupN /Time/Time/DateStrings.cpp /Time/Time/DateStrings.cpp
--- /Time/Time/DateStrings.cpp	2010-03-06 11:09:22.000000000 +0530
+++ /Time/Time/DateStrings.cpp	2013-03-24 00:28:08.000000000 +0530
@@ -1,80 +1,90 @@
-/* DateStrings.cpp
- * Definitions for date strings for use with the Time library
- *
- * No memory is consumed in the sketch if your code does not call any of the string methods
- * You can change the text of the strings, make sure the short strings are each exactly 3 characters 
- * the long strings can be any length up to the constant dt_MAX_STRING_LEN defined in Time.h
- * 
- */
- 
-#include <avr/pgmspace.h> 
-#include "Time.h"
- 
-// the short strings for each day or month must be exactly dt_SHORT_STR_LEN
-#define dt_SHORT_STR_LEN  3 // the length of short strings
-
-static char buffer[dt_MAX_STRING_LEN+1];  // must be big enough for longest string and the terminating null
-
-char monthStr1[] PROGMEM = "January";
-char monthStr2[] PROGMEM = "February";
-char monthStr3[] PROGMEM = "March";
-char monthStr4[] PROGMEM = "April";
-char monthStr5[] PROGMEM = "May";
-char monthStr6[] PROGMEM = "June";
-char monthStr7[] PROGMEM = "July";
-char monthStr8[] PROGMEM = "August";
-char monthStr9[] PROGMEM = "September";
-char monthStr10[] PROGMEM = "October";
-char monthStr11[] PROGMEM = "November";
-char monthStr12[] PROGMEM = "December";
-
-PGM_P monthNames_P[] PROGMEM = 
-{
-    "",monthStr1,monthStr2,monthStr3,monthStr4,monthStr5,monthStr6,
-	monthStr7,monthStr8,monthStr9,monthStr10,monthStr11,monthStr12
-};
-
-char monthShortNames_P[] PROGMEM = "ErrJanFebMarAprMayJunJulAugSepOctNovDec";
-
-char dayStr0[] PROGMEM = "Err";
-char dayStr1[] PROGMEM = "Sunday";
-char dayStr2[] PROGMEM = "Monday";
-char dayStr3[] PROGMEM = "Tuesday";
-char dayStr4[] PROGMEM = "Wednesday";
-char dayStr5[] PROGMEM = "Thursday";
-char dayStr6[] PROGMEM = "Friday";
-char dayStr7[] PROGMEM = "Saturday";
-
-PGM_P dayNames_P[] PROGMEM = { dayStr0,dayStr1,dayStr2,dayStr3,dayStr4,dayStr5,dayStr6,dayStr7};
-char dayShortNames_P[] PROGMEM = "ErrSunMonTueWedThrFriSat";
-
-/* functions to return date strings */
-
-char* monthStr(uint8_t month)
-{
-    strcpy_P(buffer, (PGM_P)pgm_read_word(&(monthNames_P[month])));
-	return buffer;
-}
-
-char* monthShortStr(uint8_t month)
-{
-   for (int i=0; i < dt_SHORT_STR_LEN; i++)      
-      buffer[i] = pgm_read_byte(&(monthShortNames_P[i+ (month*dt_SHORT_STR_LEN)]));  
-   buffer[dt_SHORT_STR_LEN] = 0;
-   return buffer;
-}
-
-char* dayStr(uint8_t day) 
-{
-   strcpy_P(buffer, (PGM_P)pgm_read_word(&(dayNames_P[day])));
-   return buffer;
-}
-
-char* dayShortStr(uint8_t day) 
-{
-   uint8_t index = day*dt_SHORT_STR_LEN;
-   for (int i=0; i < dt_SHORT_STR_LEN; i++)      
-      buffer[i] = pgm_read_byte(&(dayShortNames_P[index + i]));  
-   buffer[dt_SHORT_STR_LEN] = 0; 
-   return buffer;
-}
+/* DateStrings.cpp
+ * Definitions for date strings for use with the Time library
+ *
+ * No memory is consumed in the sketch if your code does not call any of the string methods
+ * You can change the text of the strings, make sure the short strings are each exactly 3 characters 
+ * the long strings can be any length up to the constant dt_MAX_STRING_LEN defined in Time.h
+ * 
+ */
+
+#if defined(__AVR__)
+#include <avr/pgmspace.h>
+#else
+// for compatiblity with Arduino Due and Teensy 3.0 and maybe others?
+#define PROGMEM
+#define PGM_P  const char *
+#define pgm_read_byte(addr) (*(const unsigned char *)(addr))
+#define pgm_read_word(addr) (*(const unsigned char **)(addr))
+#define strcpy_P(dest, src) strcpy((dest), (src))
+#endif
+#include <string.h> // for strcpy_P or strcpy
+#include "Time.h"
+ 
+// the short strings for each day or month must be exactly dt_SHORT_STR_LEN
+#define dt_SHORT_STR_LEN  3 // the length of short strings
+
+static char buffer[dt_MAX_STRING_LEN+1];  // must be big enough for longest string and the terminating null
+
+const char monthStr1[] PROGMEM = "January";
+const char monthStr2[] PROGMEM = "February";
+const char monthStr3[] PROGMEM = "March";
+const char monthStr4[] PROGMEM = "April";
+const char monthStr5[] PROGMEM = "May";
+const char monthStr6[] PROGMEM = "June";
+const char monthStr7[] PROGMEM = "July";
+const char monthStr8[] PROGMEM = "August";
+const char monthStr9[] PROGMEM = "September";
+const char monthStr10[] PROGMEM = "October";
+const char monthStr11[] PROGMEM = "November";
+const char monthStr12[] PROGMEM = "December";
+
+PGM_P monthNames_P[] PROGMEM = 
+{
+    "",monthStr1,monthStr2,monthStr3,monthStr4,monthStr5,monthStr6,
+	monthStr7,monthStr8,monthStr9,monthStr10,monthStr11,monthStr12
+};
+
+const char monthShortNames_P[] PROGMEM = "ErrJanFebMarAprMayJunJulAugSepOctNovDec";
+
+const char dayStr0[] PROGMEM = "Err";
+const char dayStr1[] PROGMEM = "Sunday";
+const char dayStr2[] PROGMEM = "Monday";
+const char dayStr3[] PROGMEM = "Tuesday";
+const char dayStr4[] PROGMEM = "Wednesday";
+const char dayStr5[] PROGMEM = "Thursday";
+const char dayStr6[] PROGMEM = "Friday";
+const char dayStr7[] PROGMEM = "Saturday";
+
+PGM_P dayNames_P[] PROGMEM = { dayStr0,dayStr1,dayStr2,dayStr3,dayStr4,dayStr5,dayStr6,dayStr7};
+char dayShortNames_P[] PROGMEM = "ErrSunMonTueWedThrFriSat";
+
+/* functions to return date strings */
+
+char* monthStr(uint8_t month)
+{
+    strcpy_P(buffer, (PGM_P)pgm_read_word(&(monthNames_P[month])));
+	return buffer;
+}
+
+char* monthShortStr(uint8_t month)
+{
+   for (int i=0; i < dt_SHORT_STR_LEN; i++)      
+      buffer[i] = pgm_read_byte(&(monthShortNames_P[i+ (month*dt_SHORT_STR_LEN)]));  
+   buffer[dt_SHORT_STR_LEN] = 0;
+   return buffer;
+}
+
+char* dayStr(uint8_t day) 
+{
+   strcpy_P(buffer, (PGM_P)pgm_read_word(&(dayNames_P[day])));
+   return buffer;
+}
+
+char* dayShortStr(uint8_t day) 
+{
+   uint8_t index = day*dt_SHORT_STR_LEN;
+   for (int i=0; i < dt_SHORT_STR_LEN; i++)      
+      buffer[i] = pgm_read_byte(&(dayShortNames_P[index + i]));  
+   buffer[dt_SHORT_STR_LEN] = 0; 
+   return buffer;
+}
diff -rupN /Time/Time/examples/Processing/SyncArduinoClock/readme.txt /Time/Time/examples/Processing/SyncArduinoClock/readme.txt
--- /Time/Time/examples/Processing/SyncArduinoClock/readme.txt	1970-01-01 05:30:00.000000000 +0530
+++ /Time/Time/examples/Processing/SyncArduinoClock/readme.txt	2013-03-28 07:20:13.000000000 +0530
@@ -0,0 +1,9 @@
+SyncArduinoClock is a Processing sketch that responds to Arduino requests for 
+time synchronization messages.
+
+The portIndex must be set the Serial port connected to Arduino.
+
+Download TimeSerial.pde onto Arduino and you should see the time 
+message displayed when you run SyncArduinoClock in Processing.
+The Arduino time is set from the time on your computer through the 
+Processing sketch. 
diff -rupN /Time/Time/examples/Processing/SyncArduinoClock/SyncArduinoClock.pde /Time/Time/examples/Processing/SyncArduinoClock/SyncArduinoClock.pde
--- /Time/Time/examples/Processing/SyncArduinoClock/SyncArduinoClock.pde	1970-01-01 05:30:00.000000000 +0530
+++ /Time/Time/examples/Processing/SyncArduinoClock/SyncArduinoClock.pde	2013-03-28 08:26:26.000000000 +0530
@@ -0,0 +1,78 @@
+/**
+ * SyncArduinoClock. 
+ *
+ * portIndex must be set to the port connected to the Arduino
+ * 
+ * The current time is sent in response to request message from Arduino 
+ * or by clicking the display window 
+ *
+ * The time message is 11 ASCII text characters; a header (the letter 'T')
+ * followed by the ten digit system time (unix time)
+ */
+ 
+
+import processing.serial.*;
+import java.util.Date;
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+
+public static final short portIndex = 0;  // select the com port, 0 is the first port
+public static final String TIME_HEADER = "T"; //header for arduino serial time message 
+public static final char TIME_REQUEST = 7;  // ASCII bell character 
+public static final char LF = 10;     // ASCII linefeed
+public static final char CR = 13;     // ASCII linefeed
+Serial myPort;     // Create object from Serial class
+
+void setup() {  
+  size(200, 200);
+  println(Serial.list());
+  println(" Connecting to -> " + Serial.list()[portIndex]);
+  myPort = new Serial(this,Serial.list()[portIndex], 9600);
+  println(getTimeNow());
+}
+
+void draw()
+{
+  textSize(20);
+  textAlign(CENTER);
+  fill(0);
+  text("Click to send\nTime Sync", 0, 75, 200, 175);
+  if ( myPort.available() > 0) {  // If data is available,
+    char val = char(myPort.read());         // read it and store it in val
+    if(val == TIME_REQUEST){
+       long t = getTimeNow();
+       sendTimeMessage(TIME_HEADER, t);   
+    }
+    else
+    { 
+       if(val == LF)
+           ; //igonore
+       else if(val == CR)           
+         println();
+       else  
+         print(val); // echo everying but time request
+    }
+  }  
+}
+
+void mousePressed() {  
+  sendTimeMessage( TIME_HEADER, getTimeNow());   
+}
+
+
+void sendTimeMessage(String header, long time) {  
+  String timeStr = String.valueOf(time);  
+  myPort.write(header);  // send header and time to arduino
+  myPort.write(timeStr); 
+  myPort.write('\n');  
+}
+
+long getTimeNow(){
+  // java time is in ms, we want secs    
+  Date d = new Date();
+  Calendar cal = new GregorianCalendar();
+  long current = d.getTime()/1000;
+  long timezone = cal.get(cal.ZONE_OFFSET)/1000;
+  long daylight = cal.get(cal.DST_OFFSET)/1000;
+  return current + timezone + daylight; 
+}
diff -rupN /Time/Time/examples/TimeArduinoDue/TimeArduinoDue.ino /Time/Time/examples/TimeArduinoDue/TimeArduinoDue.ino
--- /Time/Time/examples/TimeArduinoDue/TimeArduinoDue.ino	1970-01-01 05:30:00.000000000 +0530
+++ /Time/Time/examples/TimeArduinoDue/TimeArduinoDue.ino	2013-03-28 06:08:18.000000000 +0530
@@ -0,0 +1,69 @@
+/*
+ * TimeRTC.pde
+ * example code illustrating Time library with Real Time Clock.
+ *
+ * This example requires Markus Lange's Arduino Due RTC Library 
+ * https://github.com/MarkusLange/Arduino-Due-RTC-Library
+ */
+
+#include <Time.h>
+#include <rtc_clock.h>
+
+// Select the Slowclock source
+//RTC_clock rtc_clock(RC);
+RTC_clock rtc_clock(XTAL);
+
+void setup()  {
+  Serial.begin(9600);
+  rtc_clock.init();
+  if (rtc_clock.date_already_set() == 0) {
+    // Unfortunately, the Arduino Due hardware does not seem to
+    // be designed to maintain the RTC clock state when the
+    // board resets.  Markus described it thusly: "Uhh the Due
+    // does reset with the NRSTB pin.  This resets the full chip
+    // with all backup regions including RTC, RTT and SC.  Only
+    // if the reset is done with the NRST pin will these regions
+    // stay with their old values."
+    rtc_clock.set_time(__TIME__);
+    rtc_clock.set_date(__DATE__);
+  }
+  setSyncProvider(getArduinoDueTime);
+  if(timeStatus()!= timeSet) 
+     Serial.println("Unable to sync with the RTC");
+  else
+     Serial.println("RTC has set the system time");      
+}
+
+time_t getArduinoDueTime()
+{
+  return rtc_clock.unixtime();
+}
+
+void loop()
+{
+   digitalClockDisplay();
+   delay(1000);
+}
+
+void digitalClockDisplay(){
+  // digital clock display of the time
+  Serial.print(hour());
+  printDigits(minute());
+  printDigits(second());
+  Serial.print(" ");
+  Serial.print(day());
+  Serial.print(" ");
+  Serial.print(month());
+  Serial.print(" ");
+  Serial.print(year()); 
+  Serial.println(); 
+}
+
+void printDigits(int digits){
+  // utility function for digital clock display: prints preceding colon and leading 0
+  Serial.print(":");
+  if(digits < 10)
+    Serial.print('0');
+  Serial.print(digits);
+}
+
diff -rupN /Time/Time/examples/TimeGPS/TimeGPS.ino /Time/Time/examples/TimeGPS/TimeGPS.ino
--- /Time/Time/examples/TimeGPS/TimeGPS.ino	1970-01-01 05:30:00.000000000 +0530
+++ /Time/Time/examples/TimeGPS/TimeGPS.ino	2013-03-31 01:18:40.000000000 +0530
@@ -0,0 +1,87 @@
+/*
+ * TimeGPS.pde
+ * example code illustrating time synced from a GPS
+ * 
+ */
+
+#include <Time.h>
+#include <TinyGPS.h>       // http://arduiniana.org/libraries/TinyGPS/
+#include <SoftwareSerial.h>
+// TinyGPS and SoftwareSerial libraries are the work of Mikal Hart
+
+SoftwareSerial SerialGPS = SoftwareSerial(10, 11);  // receive on pin 10
+TinyGPS gps; 
+
+// To use a hardware serial port, which is far more efficient than
+// SoftwareSerial, uncomment this line and remove SoftwareSerial
+//#define SerialGPS Serial1
+
+// Offset hours from gps time (UTC)
+const int offset = 1;   // Central European Time
+//const int offset = -5;  // Eastern Standard Time (USA)
+//const int offset = -4;  // Eastern Daylight Time (USA)
+//const int offset = -8;  // Pacific Standard Time (USA)
+//const int offset = -7;  // Pacific Daylight Time (USA)
+
+// Ideally, it should be possible to learn the time zone
+// based on the GPS position data.  However, that would
+// require a complex library, probably incorporating some
+// sort of database using Eric Muller's time zone shape
+// maps, at http://efele.net/maps/tz/
+
+time_t prevDisplay = 0; // when the digital clock was displayed
+
+void setup()
+{
+  Serial.begin(9600);
+  while (!Serial) ; // Needed for Leonardo only
+  SerialGPS.begin(4800);
+  Serial.println("Waiting for GPS time ... ");
+}
+
+void loop()
+{
+  while (SerialGPS.available()) {
+    if (gps.encode(SerialGPS.read())) { // process gps messages
+      // when TinyGPS reports new data...
+      unsigned long age;
+      int Year;
+      byte Month, Day, Hour, Minute, Second;
+      gps.crack_datetime(&Year, &Month, &Day, &Hour, &Minute, &Second, NULL, &age);
+      if (age < 500) {
+        // set the Time to the latest GPS reading
+        setTime(Hour, Minute, Second, Day, Month, Year);
+        adjustTime(offset * SECS_PER_HOUR);
+      }
+    }
+  }
+  if (timeStatus()!= timeNotSet) {
+    if (now() != prevDisplay) { //update the display only if the time has changed
+      prevDisplay = now();
+      digitalClockDisplay();  
+    }
+  }
+}
+
+void digitalClockDisplay(){
+  // digital clock display of the time
+  Serial.print(hour());
+  printDigits(minute());
+  printDigits(second());
+  Serial.print(" ");
+  Serial.print(day());
+  Serial.print(" ");
+  Serial.print(month());
+  Serial.print(" ");
+  Serial.print(year()); 
+  Serial.println(); 
+}
+
+void printDigits(int digits) {
+  // utility function for digital clock display: prints preceding colon and leading 0
+  Serial.print(":");
+  if(digits < 10)
+    Serial.print('0');
+  Serial.print(digits);
+}
+
diff -rupN /Time/Time/examples/TimeNTP/TimeNTP.ino /Time/Time/examples/TimeNTP/TimeNTP.ino
--- /Time/Time/examples/TimeNTP/TimeNTP.ino	1970-01-01 05:30:00.000000000 +0530
+++ /Time/Time/examples/TimeNTP/TimeNTP.ino	2013-03-31 01:19:07.000000000 +0530
@@ -0,0 +1,135 @@
+/*
+ * Time_NTP.pde
+ * Example showing time sync to NTP time source
+ *
+ * This sketch uses the Ethernet library
+ */
+ 
+#include <Time.h> 
+#include <Ethernet.h>
+#include <EthernetUdp.h>
+#include <SPI.h>
+
+byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; 
+// NTP Servers:
+IPAddress timeServer(132, 163, 4, 101); // time-a.timefreq.bldrdoc.gov
+// IPAddress timeServer(132, 163, 4, 102); // time-b.timefreq.bldrdoc.gov
+// IPAddress timeServer(132, 163, 4, 103); // time-c.timefreq.bldrdoc.gov
+
+
+const int timeZone = 1;     // Central European Time
+//const int timeZone = -5;  // Eastern Standard Time (USA)
+//const int timeZone = -4;  // Eastern Daylight Time (USA)
+//const int timeZone = -8;  // Pacific Standard Time (USA)
+//const int timeZone = -7;  // Pacific Daylight Time (USA)
+
+
+EthernetUDP Udp;
+unsigned int localPort = 8888;  // local port to listen for UDP packets
+
+void setup() 
+{
+  Serial.begin(9600);
+  while (!Serial) ; // Needed for Leonardo only
+  delay(250);
+  Serial.println("TimeNTP Example");
+  if (Ethernet.begin(mac) == 0) {
+    // no point in carrying on, so do nothing forevermore:
+    while (1) {
+      Serial.println("Failed to configure Ethernet using DHCP");
+      delay(10000);
+    }
+  }
+  Serial.print("IP number assigned by DHCP is ");
+  Serial.println(Ethernet.localIP());
+  Udp.begin(localPort);
+  Serial.println("waiting for sync");
+  setSyncProvider(getNtpTime);
+}
+
+time_t prevDisplay = 0; // when the digital clock was displayed
+
+void loop()
+{  
+  if (timeStatus() != timeNotSet) {
+    if (now() != prevDisplay) { //update the display only if time has changed
+      prevDisplay = now();
+      digitalClockDisplay();  
+    }
+  }
+}
+
+void digitalClockDisplay(){
+  // digital clock display of the time
+  Serial.print(hour());
+  printDigits(minute());
+  printDigits(second());
+  Serial.print(" ");
+  Serial.print(day());
+  Serial.print(" ");
+  Serial.print(month());
+  Serial.print(" ");
+  Serial.print(year()); 
+  Serial.println(); 
+}
+
+void printDigits(int digits){
+  // utility for digital clock display: prints preceding colon and leading 0
+  Serial.print(":");
+  if(digits < 10)
+    Serial.print('0');
+  Serial.print(digits);
+}
+
+/*-------- NTP code ----------*/
+
+const int NTP_PACKET_SIZE = 48; // NTP time is in the first 48 bytes of message
+byte packetBuffer[NTP_PACKET_SIZE]; //buffer to hold incoming & outgoing packets
+
+time_t getNtpTime()
+{
+  while (Udp.parsePacket() > 0) ; // discard any previously received packets
+  Serial.println("Transmit NTP Request");
+  sendNTPpacket(timeServer);
+  uint32_t beginWait = millis();
+  while (millis() - beginWait < 1500) {
+    int size = Udp.parsePacket();
+    if (size >= NTP_PACKET_SIZE) {
+      Serial.println("Receive NTP Response");
+      Udp.read(packetBuffer, NTP_PACKET_SIZE);  // read packet into the buffer
+      unsigned long secsSince1900;
+      // convert four bytes starting at location 40 to a long integer
+      secsSince1900 =  (unsigned long)packetBuffer[40] << 24;
+      secsSince1900 |= (unsigned long)packetBuffer[41] << 16;
+      secsSince1900 |= (unsigned long)packetBuffer[42] << 8;
+      secsSince1900 |= (unsigned long)packetBuffer[43];
+      return secsSince1900 - 2208988800UL + timeZone * SECS_PER_HOUR;
+    }
+  }
+  Serial.println("No NTP Response :-(");
+  return 0; // return 0 if unable to get the time
+}
+
+// send an NTP request to the time server at the given address
+void sendNTPpacket(IPAddress &address)
+{
+  // set all bytes in the buffer to 0
+  memset(packetBuffer, 0, NTP_PACKET_SIZE);
+  // Initialize values needed to form NTP request
+  // (see URL above for details on the packets)
+  packetBuffer[0] = 0b11100011;   // LI, Version, Mode
+  packetBuffer[1] = 0;     // Stratum, or type of clock
+  packetBuffer[2] = 6;     // Polling Interval
+  packetBuffer[3] = 0xEC;  // Peer Clock Precision
+  // 8 bytes of zero for Root Delay & Root Dispersion
+  packetBuffer[12]  = 49;
+  packetBuffer[13]  = 0x4E;
+  packetBuffer[14]  = 49;
+  packetBuffer[15]  = 52;
+  // all NTP fields have been given values, now
+  // you can send a packet requesting a timestamp:                 
+  Udp.beginPacket(address, 123); //NTP requests are to port 123
+  Udp.write(packetBuffer, NTP_PACKET_SIZE);
+  Udp.endPacket();
+}
+
diff -rupN /Time/Time/examples/TimeRTC/TimeRTC.pde /Time/Time/examples/TimeRTC/TimeRTC.pde
--- /Time/Time/examples/TimeRTC/TimeRTC.pde	1970-01-01 05:30:00.000000000 +0530
+++ /Time/Time/examples/TimeRTC/TimeRTC.pde	2013-03-24 10:27:58.000000000 +0530
@@ -0,0 +1,55 @@
+/*
+ * TimeRTC.pde
+ * example code illustrating Time library with Real Time Clock.
+ * 
+ */
+
+#include <Time.h>  
+#include <Wire.h>  
+#include <DS1307RTC.h>  // a basic DS1307 library that returns time as a time_t
+
+void setup()  {
+  Serial.begin(9600);
+  while (!Serial) ; // wait until Arduino Serial Monitor opens
+  setSyncProvider(RTC.get);   // the function to get the time from the RTC
+  if(timeStatus()!= timeSet) 
+     Serial.println("Unable to sync with the RTC");
+  else
+     Serial.println("RTC has set the system time");      
+}
+
+void loop()
+{
+  if (timeStatus() == timeSet) {
+    digitalClockDisplay();
+  } else {
+    Serial.println("The time has not been set.  Please run the Time");
+    Serial.println("TimeRTCSet example, or DS1307RTC SetTime example.");
+    Serial.println();
+    delay(4000);
+  }
+  delay(1000);
+}
+
+void digitalClockDisplay(){
+  // digital clock display of the time
+  Serial.print(hour());
+  printDigits(minute());
+  printDigits(second());
+  Serial.print(" ");
+  Serial.print(day());
+  Serial.print(" ");
+  Serial.print(month());
+  Serial.print(" ");
+  Serial.print(year()); 
+  Serial.println(); 
+}
+
+void printDigits(int digits){
+  // utility function for digital clock display: prints preceding colon and leading 0
+  Serial.print(":");
+  if(digits < 10)
+    Serial.print('0');
+  Serial.print(digits);
+}
+
diff -rupN /Time/Time/examples/TimeRTCLog/TimeRTCLog.pde /Time/Time/examples/TimeRTCLog/TimeRTCLog.pde
--- /Time/Time/examples/TimeRTCLog/TimeRTCLog.pde	1970-01-01 05:30:00.000000000 +0530
+++ /Time/Time/examples/TimeRTCLog/TimeRTCLog.pde	2013-03-24 14:52:52.000000000 +0530
@@ -0,0 +1,107 @@
+/*
+ * TimeRTCLogger.pde
+ * example code illustrating adding and subtracting Time.
+ * 
+ * this sketch logs pin state change events
+ * the time of the event and time since the previous event is calculated and sent to the serial port. 
+ */
+
+#include <Time.h>  
+#include <Wire.h>  
+#include <DS1307RTC.h>  // a basic DS1307 library that returns time as a time_t
+
+const int nbrInputPins  = 6;             // monitor 6 digital pins 
+const int inputPins[nbrInputPins] = {2,3,4,5,6,7};  // pins to monitor
+boolean state[nbrInputPins] ;            // the state of the monitored pins
+time_t  prevEventTime[nbrInputPins] ;    // the time of the previous event
+
+void setup()  {
+  Serial.begin(9600);
+  setSyncProvider(RTC.get);   // the function to sync the time from the RTC  
+  for(int i=0; i < nbrInputPins; i++){
+     pinMode( inputPins[i], INPUT);
+     // uncomment these lines if pull-up resistors are wanted
+     // pinMode( inputPins[i], INPUT_PULLUP);
+     // state[i] = HIGH;
+  }
+}
+
+void loop()
+{
+   for(int i=0; i < nbrInputPins; i++)
+   {
+     boolean val = digitalRead(inputPins[i]); 
+     if(val != state[i])
+     {
+        time_t duration = 0; // the time since the previous event
+        state[i] = val;
+        time_t timeNow = now();
+        if(prevEventTime[i] > 0)  
+           // if this was not the first state change, calculate the time from the previous change
+           duration = duration = timeNow - prevEventTime[i];         
+        logEvent(inputPins[i], val, timeNow, duration );  // log the event
+        prevEventTime[i] = timeNow;                       // store the time for this event  
+     }
+   }
+}
+
+void logEvent( int pin, boolean state, time_t timeNow, time_t duration)
+{
+   Serial.print("Pin ");
+   Serial.print(pin);
+   if( state == HIGH)
+      Serial.print(" went High at ");
+   else   
+     Serial.print(" went  Low at ");
+   showTime(timeNow); 
+   if(duration > 0){
+     // only display duration if greater than 0  
+     Serial.print(", Duration was ");
+     showDuration(duration);
+   }
+   Serial.println();
+}
+
+
+void showTime(time_t t){
+  // display the given time 
+  Serial.print(hour(t));
+  printDigits(minute(t));
+  printDigits(second(t));
+  Serial.print(" ");
+  Serial.print(day(t));
+  Serial.print(" ");
+  Serial.print(month(t));
+  Serial.print(" ");
+  Serial.print(year(t)); 
+}
+
+void printDigits(int digits){
+  // utility function for digital clock display: prints preceding colon and leading 0
+  Serial.print(":");
+  if(digits < 10)
+    Serial.print('0');
+  Serial.print(digits);
+}
+
+void showDuration(time_t duration){
+// prints the duration in days, hours, minutes and seconds
+  if(duration >= SECS_PER_DAY){
+     Serial.print(duration / SECS_PER_DAY);
+     Serial.print(" day(s) "); 
+     duration = duration % SECS_PER_DAY;     
+  }
+  if(duration >= SECS_PER_HOUR){
+     Serial.print(duration / SECS_PER_HOUR);
+     Serial.print(" hour(s) "); 
+     duration = duration % SECS_PER_HOUR;     
+  }
+  if(duration >= SECS_PER_MIN){
+     Serial.print(duration / SECS_PER_MIN);
+     Serial.print(" minute(s) "); 
+     duration = duration % SECS_PER_MIN;     
+  }
+  Serial.print(duration);
+  Serial.print(" second(s) ");   
+}
+
diff -rupN /Time/Time/examples/TimeRTCSet/TimeRTCSet.ino /Time/Time/examples/TimeRTCSet/TimeRTCSet.ino
--- /Time/Time/examples/TimeRTCSet/TimeRTCSet.ino	1970-01-01 05:30:00.000000000 +0530
+++ /Time/Time/examples/TimeRTCSet/TimeRTCSet.ino	2013-03-31 01:19:58.000000000 +0530
@@ -0,0 +1,80 @@
+/*
+ * TimeRTCSet.pde
+ * example code illustrating Time library with Real Time Clock.
+ *
+ * RTC clock is set in response to serial port time message 
+ * A Processing example sketch to set the time is included in the download
+ * On Linux, you can use "date +T%s > /dev/ttyACM0" (UTC time zone)
+ */
+
+#include <Time.h>  
+#include <Wire.h>  
+#include <DS1307RTC.h>  // a basic DS1307 library that returns time as a time_t
+
+
+void setup()  {
+  Serial.begin(9600);
+  while (!Serial) ; // Needed for Leonardo only
+  setSyncProvider(RTC.get);   // the function to get the time from the RTC
+  if (timeStatus() != timeSet) 
+     Serial.println("Unable to sync with the RTC");
+  else
+     Serial.println("RTC has set the system time");      
+}
+
+void loop()
+{
+  if (Serial.available()) {
+    time_t t = processSyncMessage();
+    if (t != 0) {
+      RTC.set(t);   // set the RTC and the system time to the received value
+      setTime(t);          
+    }
+  }
+  digitalClockDisplay();  
+  delay(1000);
+}
+
+void digitalClockDisplay(){
+  // digital clock display of the time
+  Serial.print(hour());
+  printDigits(minute());
+  printDigits(second());
+  Serial.print(" ");
+  Serial.print(day());
+  Serial.print(" ");
+  Serial.print(month());
+  Serial.print(" ");
+  Serial.print(year()); 
+  Serial.println(); 
+}
+
+void printDigits(int digits){
+  // utility function for digital clock display: prints preceding colon and leading 0
+  Serial.print(":");
+  if(digits < 10)
+    Serial.print('0');
+  Serial.print(digits);
+}
+
+/*  code to process time sync messages from the serial port   */
+#define TIME_HEADER  "T"   // Header tag for serial time sync message
+
+unsigned long processSyncMessage() {
+  unsigned long pctime = 0L;
+  const unsigned long DEFAULT_TIME = 1357041600; // Jan 1 2013 
+
+  if(Serial.find(TIME_HEADER)) {
+     pctime = Serial.parseInt();
+     return pctime;
+     if( pctime < DEFAULT_TIME) { // check the value is a valid time (greater than Jan 1 2013)
+       pctime = 0L; // return 0 to indicate that the time is not valid
+     }
+  }
+  return pctime;
+}
+
+
+
+
+
diff -rupN /Time/Time/examples/TimeSerial/TimeSerial.ino /Time/Time/examples/TimeSerial/TimeSerial.ino
--- /Time/Time/examples/TimeSerial/TimeSerial.ino	1970-01-01 05:30:00.000000000 +0530
+++ /Time/Time/examples/TimeSerial/TimeSerial.ino	2013-03-31 01:20:31.000000000 +0530
@@ -0,0 +1,81 @@
+/* 
+ * TimeSerial.pde
+ * example code illustrating Time library set through serial port messages.
+ *
+ * Messages consist of the letter T followed by ten digit time (as seconds since Jan 1 1970)
+ * you can send the text on the next line using Serial Monitor to set the clock to noon Jan 1 2013
+ T1357041600  
+ *
+ * A Processing example sketch to automatically send the messages is inclided in the download
+ * On Linux, you can use "date +T%s > /dev/ttyACM0" (UTC time zone)
+ */ 
+ 
+#include <Time.h>  
+
+#define TIME_HEADER  "T"   // Header tag for serial time sync message
+#define TIME_REQUEST  7    // ASCII bell character requests a time sync message 
+
+void setup()  {
+  Serial.begin(9600);
+  while (!Serial) ; // Needed for Leonardo only
+  pinMode(13, OUTPUT);
+  setSyncProvider( requestSync);  //set function to call when sync required
+  Serial.println("Waiting for sync message");
+}
+
+void loop(){    
+  if (Serial.available()) {
+    processSyncMessage();
+  }
+  if (timeStatus()!= timeNotSet) {
+    digitalClockDisplay();  
+  }
+  if (timeStatus() == timeSet) {
+    digitalWrite(13, HIGH); // LED on if synced
+  } else {
+    digitalWrite(13, LOW);  // LED off if needs refresh
+  }
+  delay(1000);
+}
+
+void digitalClockDisplay(){
+  // digital clock display of the time
+  Serial.print(hour());
+  printDigits(minute());
+  printDigits(second());
+  Serial.print(" ");
+  Serial.print(day());
+  Serial.print(" ");
+  Serial.print(month());
+  Serial.print(" ");
+  Serial.print(year()); 
+  Serial.println(); 
+}
+
+void printDigits(int digits){
+  // utility function for digital clock display: prints preceding colon and leading 0
+  Serial.print(":");
+  if(digits < 10)
+    Serial.print('0');
+  Serial.print(digits);
+}
+
+
+void processSyncMessage() {
+  unsigned long pctime;
+  const unsigned long DEFAULT_TIME = 1357041600; // Jan 1 2013
+
+  if(Serial.find(TIME_HEADER)) {
+     pctime = Serial.parseInt();
+     if( pctime >= DEFAULT_TIME) { // check the integer is a valid time (greater than Jan 1 2013)
+       setTime(pctime); // Sync Arduino clock to the time received on the serial port
+     }
+  }
+}
+
+time_t requestSync()
+{
+  Serial.write(TIME_REQUEST);  
+  return 0; // the time will be sent later in response to serial mesg
+}
+
diff -rupN /Time/Time/examples/TimeSerialDateStrings/TimeSerialDateStrings.ino /Time/Time/examples/TimeSerialDateStrings/TimeSerialDateStrings.ino
--- /Time/Time/examples/TimeSerialDateStrings/TimeSerialDateStrings.ino	1970-01-01 05:30:00.000000000 +0530
+++ /Time/Time/examples/TimeSerialDateStrings/TimeSerialDateStrings.ino	2013-03-31 01:21:31.000000000 +0530
@@ -0,0 +1,110 @@
+/* 
+ * TimeSerialDateStrings.pde
+ * example code illustrating Time library date strings
+ *
+ * This sketch adds date string functionality to TimeSerial sketch
+ * Also shows how to handle different messages
+ *
+ * A message starting with a time header sets the time
+ * A Processing example sketch to automatically send the messages is inclided in the download
+ * On Linux, you can use "date +T%s > /dev/ttyACM0" (UTC time zone)
+ *
+ * A message starting with a format header sets the date format
+ *
+ * send: Fs\n for short date format
+ * send: Fl\n for long date format 
+ */ 
+ 
+#include <Time.h>  
+
+// single character message tags
+#define TIME_HEADER   'T'   // Header tag for serial time sync message
+#define FORMAT_HEADER 'F'   // Header tag indicating a date format message
+#define FORMAT_SHORT  's'   // short month and day strings
+#define FORMAT_LONG   'l'   // (lower case l) long month and day strings
+
+#define TIME_REQUEST  7     // ASCII bell character requests a time sync message 
+
+static boolean isLongFormat = true;
+
+void setup()  {
+  Serial.begin(9600);
+  while (!Serial) ; // Needed for Leonardo only
+  setSyncProvider( requestSync);  //set function to call when sync required
+  Serial.println("Waiting for sync message");
+}
+
+void loop(){    
+  if (Serial.available()) {
+    char c = Serial.read();
+    if( c == TIME_HEADER) {
+      processSyncMessage();
+    }
+    else if( c== FORMAT_HEADER) {
+      processFormatMessage();
+    }
+  }
+  if (timeStatus()!= timeNotSet) {
+    digitalClockDisplay();  
+  }
+  delay(1000);
+}
+
+void digitalClockDisplay(){
+  // digital clock display of the time
+  Serial.print(hour());
+  printDigits(minute());
+  printDigits(second());
+  Serial.print(" ");
+  if(isLongFormat)
+    Serial.print(dayStr(weekday()));
+  else  
+   Serial.print(dayShortStr(weekday()));
+  Serial.print(" ");
+  Serial.print(day());
+  Serial.print(" ");
+  if(isLongFormat)
+     Serial.print(monthStr(month()));
+  else
+     Serial.print(monthShortStr(month()));
+  Serial.print(" ");
+  Serial.print(year()); 
+  Serial.println(); 
+}
+
+void printDigits(int digits){
+  // utility function for digital clock display: prints preceding colon and leading 0
+  Serial.print(":");
+  if(digits < 10)
+    Serial.print('0');
+  Serial.print(digits);
+}
+
+void  processFormatMessage() {
+   char c = Serial.read();
+   if( c == FORMAT_LONG){
+      isLongFormat = true;
+      Serial.println("Setting long format");
+   }
+   else if( c == FORMAT_SHORT){
+      isLongFormat = false;   
+      Serial.println("Setting short format");
+   }
+}
+
+void processSyncMessage() {
+  unsigned long pctime;
+  const unsigned long DEFAULT_TIME = 1357041600; // Jan 1 2013 - paul, perhaps we define in time.h?
+
+   pctime = Serial.parseInt();
+   if( pctime >= DEFAULT_TIME) { // check the integer is a valid time (greater than Jan 1 2013)
+     setTime(pctime); // Sync Arduino clock to the time received on the serial port
+   } 
+}
+
+time_t requestSync()
+{
+  Serial.write(TIME_REQUEST);  
+  return 0; // the time will be sent later in response to serial mesg
+}
+
diff -rupN /Time/Time/examples/TimeTeensy3/TimeTeensy3.ino /Time/Time/examples/TimeTeensy3/TimeTeensy3.ino
--- /Time/Time/examples/TimeTeensy3/TimeTeensy3.ino	1970-01-01 05:30:00.000000000 +0530
+++ /Time/Time/examples/TimeTeensy3/TimeTeensy3.ino	2013-03-28 13:53:21.000000000 +0530
@@ -0,0 +1,78 @@
+/*
+ * TimeRTC.pde
+ * example code illustrating Time library with Real Time Clock.
+ * 
+ */
+
+#include <Time.h>  
+
+void setup()  {
+  // set the Time library to use Teensy 3.0's RTC to keep time
+  setSyncProvider(getTeensy3Time);
+
+  Serial.begin(115200);
+  while (!Serial);  // Wait for Arduino Serial Monitor to open
+  delay(100);
+  if (timeStatus()!= timeSet) {
+    Serial.println("Unable to sync with the RTC");
+  } else {
+    Serial.println("RTC has set the system time");
+  }
+}
+
+void loop() {
+  if (Serial.available()) {
+    time_t t = processSyncMessage();
+    if (t != 0) {
+      Teensy3Clock.set(t); // set the RTC
+      setTime(t);
+    }
+  }
+  digitalClockDisplay();  
+  delay(1000);
+}
+
+void digitalClockDisplay() {
+  // digital clock display of the time
+  Serial.print(hour());
+  printDigits(minute());
+  printDigits(second());
+  Serial.print(" ");
+  Serial.print(day());
+  Serial.print(" ");
+  Serial.print(month());
+  Serial.print(" ");
+  Serial.print(year()); 
+  Serial.println(); 
+}
+
+time_t getTeensy3Time()
+{
+  return Teensy3Clock.get();
+}
+
+/*  code to process time sync messages from the serial port   */
+#define TIME_HEADER  "T"   // Header tag for serial time sync message
+
+unsigned long processSyncMessage() {
+  unsigned long pctime = 0L;
+  const unsigned long DEFAULT_TIME = 1357041600; // Jan 1 2013 
+
+  if(Serial.find(TIME_HEADER)) {
+     pctime = Serial.parseInt();
+     return pctime;
+     if( pctime < DEFAULT_TIME) { // check the value is a valid time (greater than Jan 1 2013)
+       pctime = 0L; // return 0 to indicate that the time is not valid
+     }
+  }
+  return pctime;
+}
+
+void printDigits(int digits){
+  // utility function for digital clock display: prints preceding colon and leading 0
+  Serial.print(":");
+  if(digits < 10)
+    Serial.print('0');
+  Serial.print(digits);
+}
+
diff -rupN /Time/Time/Examples/Processing/SyncArduinoClock/readme.txt /Time/Time/Examples/Processing/SyncArduinoClock/readme.txt
--- /Time/Time/Examples/Processing/SyncArduinoClock/readme.txt	2009-12-29 17:24:28.000000000 +0530
+++ /Time/Time/Examples/Processing/SyncArduinoClock/readme.txt	1970-01-01 05:30:00.000000000 +0530
@@ -1,9 +0,0 @@
-SyncArduinoClock is a Processing sketch that responds to Arduino requests for 
-time synchronization messages.
-
-The portIndex must be set the Serial port connected to Arduino.
-
-Download TimeSerial.pde onto Arduino and you should see the time 
-message displayed when you run SyncArduinoClock in Processing.
-The Arduino time is set from the time on your computer through the 
-Processing sketch. 
\ No newline at end of file
diff -rupN /Time/Time/Examples/Processing/SyncArduinoClock/SyncArduinoClock.pde /Time/Time/Examples/Processing/SyncArduinoClock/SyncArduinoClock.pde
--- /Time/Time/Examples/Processing/SyncArduinoClock/SyncArduinoClock.pde	2009-12-30 18:02:06.000000000 +0530
+++ /Time/Time/Examples/Processing/SyncArduinoClock/SyncArduinoClock.pde	1970-01-01 05:30:00.000000000 +0530
@@ -1,70 +0,0 @@
-/**
- * SyncArduinoClock. 
- *
- * portIndex must be set to the port connected to the Arduino
- * 
- * The current time is sent in response to request message from Arduino 
- * or by clicking the display window 
- *
- * The time message is 11 ASCII text characters; a header (the letter 'T')
- * followed by the ten digit system time (unix time)
- */
- 
-
-import processing.serial.*;
-
-public static final short portIndex = 1;  // select the com port, 0 is the first port
-public static final char TIME_HEADER = 'T'; //header byte for arduino serial time message 
-public static final char TIME_REQUEST = 7;  // ASCII bell character 
-public static final char LF = 10;     // ASCII linefeed
-public static final char CR = 13;     // ASCII linefeed
-Serial myPort;     // Create object from Serial class
-
-void setup() {  
-  size(200, 200);
-  println(Serial.list());
-  println(" Connecting to -> " + Serial.list()[portIndex]);
-  myPort = new Serial(this,Serial.list()[portIndex], 9600);
-}
-
-void draw()
-{
-  if ( myPort.available() > 0) {  // If data is available,
-    char val = char(myPort.read());         // read it and store it in val
-    if(val == TIME_REQUEST){
-       long t = getTimeNow();
-       sendTimeMessage(TIME_HEADER, t);   
-    }
-    else
-    { 
-       if(val == LF)
-           ; //igonore
-       else if(val == CR)           
-         println();
-       else  
-         print(val); // echo everying but time request
-    }
-  }  
-}
-
-void mousePressed() {  
-  sendTimeMessage( TIME_HEADER, getTimeNow());   
-}
-
-
-void sendTimeMessage(char header, long time) {  
-  String timeStr = String.valueOf(time);  
-  myPort.write(header);  // send header and time to arduino
-  myPort.write(timeStr);   
-}
-
-long getTimeNow(){
-  // java time is in ms, we want secs    
-  GregorianCalendar cal = new GregorianCalendar();
-  cal.setTime(new Date());
-  int	tzo = cal.get(Calendar.ZONE_OFFSET);
-  int	dst = cal.get(Calendar.DST_OFFSET);
-  long now = (cal.getTimeInMillis() / 1000) ; 
-  now = now + (tzo/1000) + (dst/1000); 
-  return now;
-}
diff -rupN /Time/Time/Examples/TimeGPS/TimeGPS.pde /Time/Time/Examples/TimeGPS/TimeGPS.pde
--- /Time/Time/Examples/TimeGPS/TimeGPS.pde	2010-01-06 09:45:10.000000000 +0530
+++ /Time/Time/Examples/TimeGPS/TimeGPS.pde	1970-01-01 05:30:00.000000000 +0530
@@ -1,82 +0,0 @@
-/*
- * TimeGPS.pde
- * example code illustrating time synced from a GPS
- * 
- */
-
-#include <Time.h>
-#include <TinyGPS.h>       //http://arduiniana.org/libraries/TinyGPS/
-#include <NewSoftSerial.h>  //http://arduiniana.org/libraries/newsoftserial/
-// GPS and NewSoftSerial libraries are the work of Mikal Hart
-
-TinyGPS gps; 
-NewSoftSerial serial_gps =  NewSoftSerial(3, 2);  // receive on pin 3
-
-const int offset = 1;   // offset hours from gps time (UTC)
-time_t prevDisplay = 0; // when the digital clock was displayed
-
-void setup()
-{
-  Serial.begin(9600);
-  serial_gps.begin(4800);
-  Serial.println("Waiting for GPS time ... ");
-  setSyncProvider(gpsTimeSync);
-}
-
-void loop()
-{
-  while (serial_gps.available()) 
-  {
-    gps.encode(serial_gps.read()); // process gps messages
-  }
-  if(timeStatus()!= timeNotSet) 
-  {
-     if( now() != prevDisplay) //update the display only if the time has changed
-     {
-       prevDisplay = now();
-       digitalClockDisplay();  
-     }
-  }	 
-}
-
-void digitalClockDisplay(){
-  // digital clock display of the time
-  Serial.print(hour());
-  printDigits(minute());
-  printDigits(second());
-  Serial.print(" ");
-  Serial.print(day());
-  Serial.print(" ");
-  Serial.print(month());
-  Serial.print(" ");
-  Serial.print(year()); 
-  Serial.println(); 
-}
-
-void printDigits(int digits){
-  // utility function for digital clock display: prints preceding colon and leading 0
-  Serial.print(":");
-  if(digits < 10)
-    Serial.print('0');
-  Serial.print(digits);
-}
-
-time_t gpsTimeSync(){
-  //  returns time if avail from gps, else returns 0
-  unsigned long fix_age = 0 ;
-  gps.get_datetime(NULL,NULL, &fix_age);
-  unsigned long time_since_last_fix;
-  if(fix_age < 1000)
-    return gpsTimeToArduinoTime(); // return time only if updated recently by gps  
-  return 0;
-}
-
-time_t gpsTimeToArduinoTime(){
-  // returns time_t from gps date and time with the given offset hours
-  tmElements_t tm;
-  int year;
-  gps.crack_datetime(&year, &tm.Month, &tm.Day, &tm.Hour, &tm.Minute, &tm.Second, NULL, NULL);
-  tm.Year = year - 1970; 
-  time_t time = makeTime(tm);
-  return time + (offset * SECS_PER_HOUR);
-}
diff -rupN /Time/Time/Examples/TimeNTP/TimeNTP.pde /Time/Time/Examples/TimeNTP/TimeNTP.pde
--- /Time/Time/Examples/TimeNTP/TimeNTP.pde	2010-03-06 19:20:14.000000000 +0530
+++ /Time/Time/Examples/TimeNTP/TimeNTP.pde	1970-01-01 05:30:00.000000000 +0530
@@ -1,120 +0,0 @@
-/*
- * Time_NTP.pde
- * Example showing time sync to NTP time source
- *
- * This sketch uses the Ethenet library with the user contributed UdpBytewise extension
- */
- 
-#include <Time.h> 
-#include <Ethernet.h>
-#include <UdpBytewise.h>  // UDP library from: bjoern@cs.stanford.edu 12/30/2008 
-#if  UDP_TX_PACKET_MAX_SIZE <64 ||  UDP_RX_PACKET_MAX_SIZE < 64
-#error : UDP packet size to small - modify UdpBytewise.h to set buffers to 64 bytes
-#endif
-/*
- *
- * You may need to modify the UdpBytewise.h library to allow enough space in the buffers for the NTP packets.
- * Open up UdpBytewse.h and set the following buffers to 64 bytes:
- *    #define UDP_TX_PACKET_MAX_SIZE 64
- *    #define UDP_RX_PACKET_MAX_SIZE 64
- */
-
-
-byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; 
-byte ip[] = { 192, 168, 1, 44 }; // set the IP address to an unused address on your network
-
-byte SNTP_server_IP[]    = { 192, 43, 244, 18}; // time.nist.gov
-//byte SNTP_server_IP[] = { 130,149,17,21};    // ntps1-0.cs.tu-berlin.de
-//byte SNTP_server_IP[] = { 192,53,103,108};   // ptbtime1.ptb.de
-
-
-time_t prevDisplay = 0; // when the digital clock was displayed
-const  long timeZoneOffset = 0L; // set this to the offset in seconds to your local time;
-
-void setup() 
-{
-  Serial.begin(9600);
-  Ethernet.begin(mac,ip);  
-  Serial.println("waiting for sync");
-  setSyncProvider(getNtpTime);
-  while(timeStatus()== timeNotSet)   
-     ; // wait until the time is set by the sync provider
-}
-
-void loop()
-{  
-  if( now() != prevDisplay) //update the display only if the time has changed
-  {
-    prevDisplay = now();
-    digitalClockDisplay();  
-  }
-}
-
-void digitalClockDisplay(){
-  // digital clock display of the time
-  Serial.print(hour());
-  printDigits(minute());
-  printDigits(second());
-  Serial.print(" ");
-  Serial.print(day());
-  Serial.print(" ");
-  Serial.print(month());
-  Serial.print(" ");
-  Serial.print(year()); 
-  Serial.println(); 
-}
-
-void printDigits(int digits){
-  // utility function for digital clock display: prints preceding colon and leading 0
-  Serial.print(":");
-  if(digits < 10)
-    Serial.print('0');
-  Serial.print(digits);
-}
-
-/*-------- NTP code ----------*/
-
-unsigned long getNtpTime()
-{
-  sendNTPpacket(SNTP_server_IP);
-  delay(1000);
-  if ( UdpBytewise.available() ) {
-    for(int i=0; i < 40; i++)
-       UdpBytewise.read(); // ignore every field except the time
-    const unsigned long seventy_years = 2208988800UL + timeZoneOffset;        
-    return getUlong() -  seventy_years;      
-  }
-  return 0; // return 0 if unable to get the time
-}
-
-unsigned long sendNTPpacket(byte *address)
-{
-  UdpBytewise.begin(123);
-  UdpBytewise.beginPacket(address, 123);
-  UdpBytewise.write(B11100011);   // LI, Version, Mode
-  UdpBytewise.write(0);    // Stratum
-  UdpBytewise.write(6);  // Polling Interval
-  UdpBytewise.write(0xEC); // Peer Clock Precision
-  write_n(0, 8);    // Root Delay & Root Dispersion
-  UdpBytewise.write(49); 
-  UdpBytewise.write(0x4E);
-  UdpBytewise.write(49);
-  UdpBytewise.write(52);
-  write_n(0, 32); //Reference and time stamps  
-  UdpBytewise.endPacket();   
-}
-
-unsigned long getUlong()
-{
-    unsigned long ulong = (unsigned long)UdpBytewise.read() << 24;
-    ulong |= (unsigned long)UdpBytewise.read() << 16;
-    ulong |= (unsigned long)UdpBytewise.read() << 8;
-    ulong |= (unsigned long)UdpBytewise.read();
-    return ulong;
-}
-
-void write_n(int what, int how_many)
-{
-  for( int i = 0; i < how_many; i++ )
-    UdpBytewise.write(what);
-}
diff -rupN /Time/Time/Examples/TimeRTC/TimeRTC.pde /Time/Time/Examples/TimeRTC/TimeRTC.pde
--- /Time/Time/Examples/TimeRTC/TimeRTC.pde	2010-01-05 14:13:46.000000000 +0530
+++ /Time/Time/Examples/TimeRTC/TimeRTC.pde	1970-01-01 05:30:00.000000000 +0530
@@ -1,47 +0,0 @@
-/*
- * TimeRTC.pde
- * example code illustrating Time library with Real Time Clock.
- * 
- */
-
-#include <Time.h>  
-#include <Wire.h>  
-#include <DS1307RTC.h>  // a basic DS1307 library that returns time as a time_t
-
-void setup()  {
-  Serial.begin(9600);
-  setSyncProvider(RTC.get);   // the function to get the time from the RTC
-  if(timeStatus()!= timeSet) 
-     Serial.println("Unable to sync with the RTC");
-  else
-     Serial.println("RTC has set the system time");      
-}
-
-void loop()
-{
-   digitalClockDisplay();  
-   delay(1000);
-}
-
-void digitalClockDisplay(){
-  // digital clock display of the time
-  Serial.print(hour());
-  printDigits(minute());
-  printDigits(second());
-  Serial.print(" ");
-  Serial.print(day());
-  Serial.print(" ");
-  Serial.print(month());
-  Serial.print(" ");
-  Serial.print(year()); 
-  Serial.println(); 
-}
-
-void printDigits(int digits){
-  // utility function for digital clock display: prints preceding colon and leading 0
-  Serial.print(":");
-  if(digits < 10)
-    Serial.print('0');
-  Serial.print(digits);
-}
-
diff -rupN /Time/Time/Examples/TimeRTCLog/TimeRTCLog.pde /Time/Time/Examples/TimeRTCLog/TimeRTCLog.pde
--- /Time/Time/Examples/TimeRTCLog/TimeRTCLog.pde	2010-01-06 10:30:36.000000000 +0530
+++ /Time/Time/Examples/TimeRTCLog/TimeRTCLog.pde	1970-01-01 05:30:00.000000000 +0530
@@ -1,106 +0,0 @@
-/*
- * TimeRTCLogger.pde
- * example code illustrating adding and subtracting Time.
- * 
- * this sketch logs pin state change events
- * the time of the event and time since the previous event is calculated and sent to the serial port. 
- */
-
-#include <Time.h>  
-#include <Wire.h>  
-#include <DS1307RTC.h>  // a basic DS1307 library that returns time as a time_t
-
-const int nbrInputPins  = 6;             // monitor 6 digital pins 
-const int inputPins[nbrInputPins] = {2,3,4,5,6,7};  // pins to monitor
-boolean state[nbrInputPins] ;            // the state of the monitored pins
-time_t  prevEventTime[nbrInputPins] ;    // the time of the previous event
-
-void setup()  {
-  Serial.begin(9600);
-  setSyncProvider(RTC.get);   // the function to sync the time from the RTC  
-  for(int i=0; i < nbrInputPins; i++){
-     pinMode( inputPins[i], INPUT);
-     // digitalWrite( inputPins[i], HIGH);  // uncomment these lines if 
-     // state[i] = HIGH;                    // pull-up resistors are wanted
-  }
-}
-
-void loop()
-{
-   for(int i=0; i < nbrInputPins; i++)
-   {
-     boolean val = digitalRead(inputPins[i]); 
-     if(val != state[i])
-     {
-        time_t duration = 0; // the time since the previous event
-        state[i] = val;
-        time_t timeNow = now();
-        if(prevEventTime[i] > 0)  
-           // if this was not the first state change, calculate the time from the previous change
-           duration = duration = timeNow - prevEventTime[i];         
-        logEvent(inputPins[i], val, timeNow, duration );  // log the event
-        prevEventTime[i] = timeNow;                       // store the time for this event  
-     }
-   }
-}
-
-void logEvent( int pin, boolean state, time_t timeNow, time_t duration)
-{
-   Serial.print("Pin ");
-   Serial.print(pin);
-   if( state == HIGH)
-      Serial.print(" went High at ");
-   else   
-     Serial.print(" went  Low at ");
-   showTime(timeNow); 
-   if(duration > 0){
-     // only display duration if greater than 0  
-     Serial.print(", Duration was ");
-     showDuration(duration);
-   }
-   Serial.println();
-}
-
-
-void showTime(time_t t){
-  // display the given time 
-  Serial.print(hour(t));
-  printDigits(minute(t));
-  printDigits(second(t));
-  Serial.print(" ");
-  Serial.print(day(t));
-  Serial.print(" ");
-  Serial.print(month(t));
-  Serial.print(" ");
-  Serial.print(year(t)); 
-}
-
-void printDigits(int digits){
-  // utility function for digital clock display: prints preceding colon and leading 0
-  Serial.print(":");
-  if(digits < 10)
-    Serial.print('0');
-  Serial.print(digits);
-}
-
-void showDuration(time_t duration){
-// prints the duration in days, hours, minutes and seconds
-  if(duration >= SECS_PER_DAY){
-     Serial.print(duration / SECS_PER_DAY);
-     Serial.print(" day(s) "); 
-     duration = duration % SECS_PER_DAY;     
-  }
-  if(duration >= SECS_PER_HOUR){
-     Serial.print(duration / SECS_PER_HOUR);
-     Serial.print(" hour(s) "); 
-     duration = duration % SECS_PER_HOUR;     
-  }
-  if(duration >= SECS_PER_MIN){
-     Serial.print(duration / SECS_PER_MIN);
-     Serial.print(" minute(s) "); 
-     duration = duration % SECS_PER_MIN;     
-  }
-  Serial.print(duration);
-  Serial.print(" second(s) ");   
-}
-
diff -rupN /Time/Time/Examples/TimeRTCSet/TimeRTCSet.pde /Time/Time/Examples/TimeRTCSet/TimeRTCSet.pde
--- /Time/Time/Examples/TimeRTCSet/TimeRTCSet.pde	2010-01-06 09:53:08.000000000 +0530
+++ /Time/Time/Examples/TimeRTCSet/TimeRTCSet.pde	1970-01-01 05:30:00.000000000 +0530
@@ -1,82 +0,0 @@
-/*
- * TimeRTCSet.pde
- * example code illustrating Time library with Real Time Clock.
- *
- * RTC clock is set in response to serial port time message 
- * A Processing example sketch to set the time is inclided in the download
- */
-
-#include <Time.h>  
-#include <Wire.h>  
-#include <DS1307RTC.h>  // a basic DS1307 library that returns time as a time_t
-
-
-void setup()  {
-  Serial.begin(9600);
-  setSyncProvider(RTC.get);   // the function to get the time from the RTC
-  if(timeStatus()!= timeSet) 
-     Serial.println("Unable to sync with the RTC");
-  else
-     Serial.println("RTC has set the system time");      
-}
-
-void loop()
-{
-  if(Serial.available())
-  {
-     time_t t = processSyncMessage();
-     if(t >0)
-     {
-        RTC.set(t);   // set the RTC and the system time to the received value
-        setTime(t);          
-     }
-  }
-   digitalClockDisplay();  
-   delay(1000);
-}
-
-void digitalClockDisplay(){
-  // digital clock display of the time
-  Serial.print(hour());
-  printDigits(minute());
-  printDigits(second());
-  Serial.print(" ");
-  Serial.print(day());
-  Serial.print(" ");
-  Serial.print(month());
-  Serial.print(" ");
-  Serial.print(year()); 
-  Serial.println(); 
-}
-
-void printDigits(int digits){
-  // utility function for digital clock display: prints preceding colon and leading 0
-  Serial.print(":");
-  if(digits < 10)
-    Serial.print('0');
-  Serial.print(digits);
-}
-
-/*  code to process time sync messages from the serial port   */
-#define TIME_MSG_LEN  11   // time sync to PC is HEADER followed by unix time_t as ten ascii digits
-#define TIME_HEADER  'T'   // Header tag for serial time sync message
-
-time_t processSyncMessage() {
-  // return the time if a valid sync message is received on the serial port.
-  while(Serial.available() >=  TIME_MSG_LEN ){  // time message consists of a header and ten ascii digits
-    char c = Serial.read() ; 
-    Serial.print(c);  
-    if( c == TIME_HEADER ) {       
-      time_t pctime = 0;
-      for(int i=0; i < TIME_MSG_LEN -1; i++){   
-        c = Serial.read();          
-        if( c >= '0' && c <= '9'){   
-          pctime = (10 * pctime) + (c - '0') ; // convert digits to a number    
-        }
-      }   
-      return pctime; 
-    }  
-  }
-  return 0;
-}
-
diff -rupN /Time/Time/Examples/TimeSerial/TimeSerial.pde /Time/Time/Examples/TimeSerial/TimeSerial.pde
--- /Time/Time/Examples/TimeSerial/TimeSerial.pde	2010-01-06 10:55:18.000000000 +0530
+++ /Time/Time/Examples/TimeSerial/TimeSerial.pde	1970-01-01 05:30:00.000000000 +0530
@@ -1,82 +0,0 @@
-/* 
- * TimeSerial.pde
- * example code illustrating Time library set through serial port messages.
- *
- * Messages consist of the letter T followed by ten digit time (as seconds since Jan 1 1970)
- * you can send the text on the next line using Serial Monitor to set the clock to noon Jan 1 2010
- T1262347200  
- *
- * A Processing example sketch to automatically send the messages is inclided in the download
- */ 
- 
-#include <Time.h>  
-
-#define TIME_MSG_LEN  11   // time sync to PC is HEADER followed by unix time_t as ten ascii digits
-#define TIME_HEADER  'T'   // Header tag for serial time sync message
-#define TIME_REQUEST  7    // ASCII bell character requests a time sync message 
-
-void setup()  {
-  Serial.begin(9600);
-  setSyncProvider( requestSync);  //set function to call when sync required
-  Serial.println("Waiting for sync message");
-}
-
-void loop(){    
-  if(Serial.available() ) 
-  {
-    processSyncMessage();
-  }
-  if(timeStatus()!= timeNotSet)   
-  {
-    digitalWrite(13,timeStatus() == timeSet); // on if synced, off if needs refresh  
-    digitalClockDisplay();  
-  }
-  delay(1000);
-}
-
-void digitalClockDisplay(){
-  // digital clock display of the time
-  Serial.print(hour());
-  printDigits(minute());
-  printDigits(second());
-  Serial.print(" ");
-  Serial.print(day());
-  Serial.print(" ");
-  Serial.print(month());
-  Serial.print(" ");
-  Serial.print(year()); 
-  Serial.println(); 
-}
-
-void printDigits(int digits){
-  // utility function for digital clock display: prints preceding colon and leading 0
-  Serial.print(":");
-  if(digits < 10)
-    Serial.print('0');
-  Serial.print(digits);
-}
-
-void processSyncMessage() {
-  // if time sync available from serial port, update time and return true
-  while(Serial.available() >=  TIME_MSG_LEN ){  // time message consists of a header and ten ascii digits
-    char c = Serial.read() ; 
-    Serial.print(c);  
-    if( c == TIME_HEADER ) {       
-      time_t pctime = 0;
-      for(int i=0; i < TIME_MSG_LEN -1; i++){   
-        c = Serial.read();          
-        if( c >= '0' && c <= '9'){   
-          pctime = (10 * pctime) + (c - '0') ; // convert digits to a number    
-        }
-      }   
-      setTime(pctime);   // Sync Arduino clock to the time received on the serial port
-    }  
-  }
-}
-
-time_t requestSync()
-{
-  Serial.print(TIME_REQUEST,BYTE);  
-  return 0; // the time will be sent later in response to serial mesg
-}
-
diff -rupN /Time/Time/Examples/TimeSerialDateStrings/TimeSerialDateStrings.pde /Time/Time/Examples/TimeSerialDateStrings/TimeSerialDateStrings.pde
--- /Time/Time/Examples/TimeSerialDateStrings/TimeSerialDateStrings.pde	2010-01-06 10:55:48.000000000 +0530
+++ /Time/Time/Examples/TimeSerialDateStrings/TimeSerialDateStrings.pde	1970-01-01 05:30:00.000000000 +0530
@@ -1,80 +0,0 @@
-/* 
- * TimeSerialDateStrings.pde
- * example code illustrating Time library date strings
- *
- * This sketch adds date string functionality to TimeSerial.pde
- * 
- */ 
- 
-#include <Time.h>  
-
-#define TIME_MSG_LEN  11   // time sync to PC is HEADER followed by unix time_t as ten ascii digits
-#define TIME_HEADER  'T'   // Header tag for serial time sync message
-#define TIME_REQUEST  7    // ASCII bell character requests a time sync message 
-
-void setup()  {
-  Serial.begin(9600);
-  setSyncProvider( requestSync);  //set function to call when sync required
-  Serial.println("Waiting for sync message");
-}
-
-void loop(){    
-  if(Serial.available() ) 
-  {
-    processSyncMessage();
-  }
-  if(timeStatus()!= timeNotSet) 
-  {
-    digitalClockDisplay();  
-  }
-  delay(1000);
-}
-
-void digitalClockDisplay(){
-  // digital clock display of the time
-  Serial.print(hour());
-  printDigits(minute());
-  printDigits(second());
-  Serial.print(" ");
-  Serial.print(dayStr(weekday()));
-  Serial.print(" ");
-  Serial.print(day());
-  Serial.print(" ");
-  Serial.print(monthShortStr(month()));
-  Serial.print(" ");
-  Serial.print(year()); 
-  Serial.println(); 
-}
-
-void printDigits(int digits){
-  // utility function for digital clock display: prints preceding colon and leading 0
-  Serial.print(":");
-  if(digits < 10)
-    Serial.print('0');
-  Serial.print(digits);
-}
-
-void processSyncMessage() {
-  // if time sync available from serial port, update time and return true
-  while(Serial.available() >=  TIME_MSG_LEN ){  // time message consists of a header and ten ascii digits
-    char c = Serial.read() ; 
-    Serial.print(c);  
-    if( c == TIME_HEADER ) {       
-      time_t pctime = 0;
-      for(int i=0; i < TIME_MSG_LEN -1; i++){   
-        c = Serial.read();          
-        if( c >= '0' && c <= '9'){   
-          pctime = (10 * pctime) + (c - '0') ; // convert digits to a number    
-        }
-      }   
-      setTime(pctime);   // Sync Arduino clock to the time received on the serial port
-    }  
-  }
-}
-
-time_t requestSync()
-{
-  Serial.print(TIME_REQUEST,BYTE);  
-  return 0; // the time will be sent later in response to serial mesg
-}
-
diff -rupN /Time/Time/keywords.txt /Time/Time/keywords.txt
--- /Time/Time/keywords.txt	2010-01-05 12:02:50.000000000 +0530
+++ /Time/Time/keywords.txt	2013-03-23 22:36:10.000000000 +0530
@@ -5,25 +5,25 @@
 #######################################
 # Datatypes (KEYWORD1)
 #######################################
-time_t KEYWORD1
+time_t	KEYWORD1
 #######################################
 # Methods and Functions (KEYWORD2)
 #######################################
 now	KEYWORD2
-second KEYWORD2
+second	KEYWORD2
 minute	KEYWORD2
-hour KEYWORD2
-day KEYWORD2
-month KEYWORD2
-year KEYWORD2
-isAM KEYWORD2
-isPM KEYWORD2
-weekday KEYWORD2
-setTime KEYWORD2
-adjustTime KEYWORD2
-setSyncProvider KEYWORD2
-setSyncInteval KEYWORD2
-timeStatus KEYWORD2
+hour	KEYWORD2
+day	KEYWORD2
+month	KEYWORD2
+year	KEYWORD2
+isAM	KEYWORD2
+isPM	KEYWORD2
+weekday	KEYWORD2
+setTime	KEYWORD2
+adjustTime	KEYWORD2
+setSyncProvider	KEYWORD2
+setSyncInterval	KEYWORD2
+timeStatus	KEYWORD2
 #######################################
 # Instances (KEYWORD2)
 #######################################
diff -rupN /Time/Time/Readme.txt /Time/Time/Readme.txt
--- /Time/Time/Readme.txt	2010-01-11 21:36:24.000000000 +0530
+++ /Time/Time/Readme.txt	2013-03-23 21:37:54.000000000 +0530
@@ -1,131 +1,131 @@
-Readme file for Arduino Time Library
-
-Time is a library that provides timekeeping functionality for Arduino.
-
-The code is derived from the Playground DateTime library but is updated
-to provide an API that is more flexable and easier to use.
-
-A primary goal was to enable date and time functionality that can be used with
-a variety of external time sources with minimum differences required in sketch logic.
-
-Example sketches illustrate how similar sketch code can be used with: a Real Time Clock,
-internet NTP time service, GPS time data, and Serial time messages from a computer
-for time synchronization.
-
-The functions available in the library include:
-
-hour();            // the hour now  (0-23)
-minute();          // the minute now (0-59)          
-second();          // the second now (0-59) 
-day();             // the day now (1-31)
-weekday();         // day of the week, Sunday is day 0 
-month();           // the month now (1-12)
-year();            // the full four digit year: (2009, 2010 etc) 
-
-there are also functions to return the hour in 12 hour format
-hourFormat12();    // the hour now in 12 hour format
-isAM();            // returns true if time now is AM 
-isPM();            // returns true if time now is PM
-
-now();             // returns the current time as seconds since Jan 1 1970 
-
-The time and date functions can take an optional parameter for the time. This prevents
-errors if the time rolls over between elements. For example, if a new minute begins
-between getting the minute and second, the values will be inconsistent. Using the 
-following functions eliminates this probglem 
-  time_t t = now(); // store the current time in time variable t 
-  hour(t);          // returns the hour for the given time t
-  minute(t);        // returns the minute for the given time t
-  second(t);        // returns the second for the given time t 
-  day(t);           // the day for the given time t 
-  weekday(t);       // day of the week for the given time t  
-  month(t);         // the month for the given time t 
-  year(t);          // the year for the given time t  
-  
-  
-Functions for managing the timer services are:  
-setTime(t);             // set the system time to the give time t
-setTime(hr,min,sec,day,mnth,yr); // alternative to above, yr is 2 or 4 digit yr (2010 or 10 sets year to 2010)
-adjustTime(adjustment); // adjust system time by adding the adjustment value
-
-timeStatus();       // indicates if time has been set and recently synchronized
-                    // returns one of the following enumerations:
-    timeNotSet      // the time has never been set, the clock started at Jan 1 1970
-    timeNeedsSync   // the time had been set but a sync attempt did not succeed
-    timeSet         // the time is set and is synced
-Time and Date values are not valid if the status is timeNotSet. Otherwise values can be used but 
-the returned time may have drifted if the status is timeNeedsSync. 	
-
-setSyncProvider(getTimeFunction);  // set the external time provider
-setSyncInterval(interval);         // set the number of seconds between re-sync
-
-
-There are many convenience macros in the time.h file for time constants and conversion of time units.
-
-To use the library, copy the download to the Library directory.
-
-The Time directory contains the Time library and some example sketches
-illustrating how the library can be used with various time sources:
-
-- TimeSerial.pde shows Arduino as a clock without external hardware.
-  It is synchronized by time messages sent over the serial port.
-  A companion Processing sketch will automatically provide these messages
-  if it is running and connected to the Arduino serial port. 
-
-- TimeSerialDateStrings.pde adds day and month name strings to the sketch above
-  Short (3 character) and long strings are available to print the days of 
-  the week and names of the months. 
-  
-- TimeRTC uses a DS1307 real time clock to provide time synchronization.
-  A basic RTC library named DS1307RTC is included in the download.
-  To run this sketch the DS1307RTC library must be installed.
-
-- TimeRTCSet is similar to the above and adds the ability to set the Real Time Clock 
-
-- TimeRTCLog demonstrates how to calculate the difference between times. 
-  It is a vary simple logger application that monitors events on digtial pins
-  and prints (to the serial port) the time of an event and the time period since the previous event.
-  
-- TimeNTP uses the Arduino Ethernet shield to access time using the internet NTP time service.
-  The NTP protocol uses UDP and the UdpBytewise library is required, see:
-  http://bitbucket.org/bjoern/arduino_osc/src/14667490521f/libraries/Ethernet/
-
--TimeGPS gets time from a GPS
- This requires the TinyGPS and NewSoftSerial libraries from Mikal Hart:
- http://arduiniana.org/libraries/TinyGPS and http://arduiniana.org/libraries/newsoftserial/
-
-Differences between this code and the playground DateTime library
-although the Time library is based on the DateTime codebase, the API has changed.
-Changes in the Time library API:
-- time elements are functions returning int (they are variables in DateTime)
-- Years start from 1970 
-- days of the week and months start from 1 (they start from 0 in DateTime)
-- DateStrings do not require a seperate library
-- time elements can be accessed non-atomically (in DateTime they are always atomic)
-- function added to automatically sync time with extrnal source
-- localTime and maketime parameters changed, localTime renamed to breakTime
- 
-Technical notes:
-
-Internal system time is based on the standard Unix time_t.
-The value is the number of seconds since Jan 1 1970.
-System time begins at zero when the sketch starts.
-  
-The internal time can be automatically synchronized at regular intervals to an external time source.
-This is enabled by calling the setSyncProvider(provider) function - the provider argument is
-the address of a function that returns the current time as a time_t.
-See the sketches in the examples directory for usage.
-
-The default interval for re-syncing the time is 5 minutes but can be changed by calling the 
-setSyncInterval( interval) method to set the number of seconds between re-sync attempts.
-
-The Time library defines a structure for holding time elements that is a compact version of the  C tm structure.
-All the members of the Arduino tm structure are bytes and the year is offset from 1970.
-Convenience macros provide conversion to and from the Arduino format.
-
-Low level functions to convert between system time and individual time elements are provided:                    
-  breakTime( time, &tm);  // break time_t into elements stored in tm struct
-  makeTime( &tm);  // return time_t  from elements stored in tm struct 
-
-The DS1307RTC library included in the download provides an example of how a time provider
-can use the low level functions to interface with the Time library.
\ No newline at end of file
+Readme file for Arduino Time Library
+
+Time is a library that provides timekeeping functionality for Arduino.
+
+The code is derived from the Playground DateTime library but is updated
+to provide an API that is more flexable and easier to use.
+
+A primary goal was to enable date and time functionality that can be used with
+a variety of external time sources with minimum differences required in sketch logic.
+
+Example sketches illustrate how similar sketch code can be used with: a Real Time Clock,
+internet NTP time service, GPS time data, and Serial time messages from a computer
+for time synchronization.
+
+The functions available in the library include:
+
+hour();            // the hour now  (0-23)
+minute();          // the minute now (0-59)          
+second();          // the second now (0-59) 
+day();             // the day now (1-31)
+weekday();         // day of the week, Sunday is day 0 
+month();           // the month now (1-12)
+year();            // the full four digit year: (2009, 2010 etc) 
+
+there are also functions to return the hour in 12 hour format
+hourFormat12();    // the hour now in 12 hour format
+isAM();            // returns true if time now is AM 
+isPM();            // returns true if time now is PM
+
+now();             // returns the current time as seconds since Jan 1 1970 
+
+The time and date functions can take an optional parameter for the time. This prevents
+errors if the time rolls over between elements. For example, if a new minute begins
+between getting the minute and second, the values will be inconsistent. Using the 
+following functions eliminates this probglem 
+  time_t t = now(); // store the current time in time variable t 
+  hour(t);          // returns the hour for the given time t
+  minute(t);        // returns the minute for the given time t
+  second(t);        // returns the second for the given time t 
+  day(t);           // the day for the given time t 
+  weekday(t);       // day of the week for the given time t  
+  month(t);         // the month for the given time t 
+  year(t);          // the year for the given time t  
+  
+  
+Functions for managing the timer services are:  
+setTime(t);             // set the system time to the give time t
+setTime(hr,min,sec,day,mnth,yr); // alternative to above, yr is 2 or 4 digit yr (2010 or 10 sets year to 2010)
+adjustTime(adjustment); // adjust system time by adding the adjustment value
+
+timeStatus();       // indicates if time has been set and recently synchronized
+                    // returns one of the following enumerations:
+    timeNotSet      // the time has never been set, the clock started at Jan 1 1970
+    timeNeedsSync   // the time had been set but a sync attempt did not succeed
+    timeSet         // the time is set and is synced
+Time and Date values are not valid if the status is timeNotSet. Otherwise values can be used but 
+the returned time may have drifted if the status is timeNeedsSync. 	
+
+setSyncProvider(getTimeFunction);  // set the external time provider
+setSyncInterval(interval);         // set the number of seconds between re-sync
+
+
+There are many convenience macros in the time.h file for time constants and conversion of time units.
+
+To use the library, copy the download to the Library directory.
+
+The Time directory contains the Time library and some example sketches
+illustrating how the library can be used with various time sources:
+
+- TimeSerial.pde shows Arduino as a clock without external hardware.
+  It is synchronized by time messages sent over the serial port.
+  A companion Processing sketch will automatically provide these messages
+  if it is running and connected to the Arduino serial port. 
+
+- TimeSerialDateStrings.pde adds day and month name strings to the sketch above
+  Short (3 character) and long strings are available to print the days of 
+  the week and names of the months. 
+  
+- TimeRTC uses a DS1307 real time clock to provide time synchronization.
+  A basic RTC library named DS1307RTC is included in the download.
+  To run this sketch the DS1307RTC library must be installed.
+
+- TimeRTCSet is similar to the above and adds the ability to set the Real Time Clock 
+
+- TimeRTCLog demonstrates how to calculate the difference between times. 
+  It is a vary simple logger application that monitors events on digtial pins
+  and prints (to the serial port) the time of an event and the time period since the previous event.
+  
+- TimeNTP uses the Arduino Ethernet shield to access time using the internet NTP time service.
+  The NTP protocol uses UDP and the UdpBytewise library is required, see:
+  http://bitbucket.org/bjoern/arduino_osc/src/14667490521f/libraries/Ethernet/
+
+- TimeGPS gets time from a GPS
+  This requires the TinyGPS library from Mikal Hart:
+  http://arduiniana.org/libraries/TinyGPS
+
+Differences between this code and the playground DateTime library
+although the Time library is based on the DateTime codebase, the API has changed.
+Changes in the Time library API:
+- time elements are functions returning int (they are variables in DateTime)
+- Years start from 1970 
+- days of the week and months start from 1 (they start from 0 in DateTime)
+- DateStrings do not require a seperate library
+- time elements can be accessed non-atomically (in DateTime they are always atomic)
+- function added to automatically sync time with extrnal source
+- localTime and maketime parameters changed, localTime renamed to breakTime
+ 
+Technical notes:
+
+Internal system time is based on the standard Unix time_t.
+The value is the number of seconds since Jan 1 1970.
+System time begins at zero when the sketch starts.
+  
+The internal time can be automatically synchronized at regular intervals to an external time source.
+This is enabled by calling the setSyncProvider(provider) function - the provider argument is
+the address of a function that returns the current time as a time_t.
+See the sketches in the examples directory for usage.
+
+The default interval for re-syncing the time is 5 minutes but can be changed by calling the 
+setSyncInterval( interval) method to set the number of seconds between re-sync attempts.
+
+The Time library defines a structure for holding time elements that is a compact version of the  C tm structure.
+All the members of the Arduino tm structure are bytes and the year is offset from 1970.
+Convenience macros provide conversion to and from the Arduino format.
+
+Low level functions to convert between system time and individual time elements are provided:                    
+  breakTime( time, &tm);  // break time_t into elements stored in tm struct
+  makeTime( &tm);  // return time_t  from elements stored in tm struct 
+
+The DS1307RTC library included in the download provides an example of how a time provider
+can use the low level functions to interface with the Time library.
diff -rupN /Time/Time/Time.cpp /Time/Time/Time.cpp
--- /Time/Time/Time.cpp	2010-11-01 18:02:50.000000000 +0530
+++ /Time/Time/Time.cpp	2013-03-28 03:19:40.000000000 +0530
@@ -19,6 +19,11 @@
   6  Jan 2010 - initial release 
   12 Feb 2010 - fixed leap year calculation error
   1  Nov 2010 - fixed setTime bug (thanks to Korman for this)
+  24 Mar 2012 - many edits by Paul Stoffregen: fixed timeStatus() to update
+                status, updated examples for Arduino 1.0, fixed ARM
+                compatibility issues, added TimeArduinoDue and TimeTeensy3
+                examples, add error checking and messages to RTC examples,
+                add examples to DS1307RTC library.
 */
 
 #if ARDUINO >= 100
@@ -30,12 +35,11 @@
 #include "Time.h"
 
 static tmElements_t tm;          // a cache of time elements
-static time_t       cacheTime;   // the time the cache was updated
-static time_t       syncInterval = 300;  // time sync will be attempted after this many seconds
+static time_t cacheTime;   // the time the cache was updated
+static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds
 
-void refreshCache( time_t t){
-  if( t != cacheTime)
-  {
+void refreshCache(time_t t) {
+  if (t != cacheTime) {
     breakTime(t, tm); 
     cacheTime = t; 
   }
@@ -143,15 +147,17 @@ int year(time_t t) { // the year for the
 
 static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
  
-void breakTime(time_t time, tmElements_t &tm){
+void breakTime(time_t timeInput, tmElements_t &tm){
 // break the given time_t into time components
 // this is a more compact version of the C library localtime function
 // note that year is offset from 1970 !!!
 
   uint8_t year;
   uint8_t month, monthLength;
+  uint32_t time;
   unsigned long days;
-  
+
+  time = (uint32_t)timeInput;
   tm.Second = time % 60;
   time /= 60; // now it is minutes
   tm.Minute = time % 60;
@@ -200,7 +206,7 @@ time_t makeTime(tmElements_t &tm){
 // previous version used full four digit year (or digits since 2000),i.e. 2009 was 2009 or 9
   
   int i;
-  time_t seconds;
+  uint32_t seconds;
 
   // seconds from 1970 till 1 jan 00:00:00 of the given year
   seconds= tm.Year*(SECS_PER_DAY * 365);
@@ -222,14 +228,14 @@ time_t makeTime(tmElements_t &tm){
   seconds+= tm.Hour * SECS_PER_HOUR;
   seconds+= tm.Minute * SECS_PER_MIN;
   seconds+= tm.Second;
-  return seconds; 
+  return (time_t)seconds; 
 }
 /*=====================================================*/	
 /* Low level system time functions  */
 
-static time_t sysTime = 0;
-static time_t prevMillis = 0;
-static time_t nextSyncTime = 0;
+static uint32_t sysTime = 0;
+static uint32_t prevMillis = 0;
+static uint32_t nextSyncTime = 0;
 static timeStatus_t Status = timeNotSet;
 
 getExternalTime getTimePtr;  // pointer to external sync function
@@ -240,39 +246,41 @@ time_t sysUnsyncedTime = 0; // the time
 #endif
 
 
-time_t now(){
-  while( millis() - prevMillis >= 1000){      
+time_t now() {
+  while (millis() - prevMillis >= 1000){      
     sysTime++;
     prevMillis += 1000;	
 #ifdef TIME_DRIFT_INFO
     sysUnsyncedTime++; // this can be compared to the synced time to measure long term drift     
-#endif	
+#endif
   }
-  if(nextSyncTime <= sysTime){
-	if(getTimePtr != 0){
-	  time_t t = getTimePtr();
-      if( t != 0)
+  if (nextSyncTime <= sysTime) {
+    if (getTimePtr != 0) {
+      time_t t = getTimePtr();
+      if (t != 0) {
         setTime(t);
-      else
-        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;        
+      } else {
+        nextSyncTime = sysTime + syncInterval;
+        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
+      }
     }
   }  
-  return sysTime;
+  return (time_t)sysTime;
 }
 
-void setTime(time_t t){ 
+void setTime(time_t t) { 
 #ifdef TIME_DRIFT_INFO
  if(sysUnsyncedTime == 0) 
    sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
 #endif
 
-  sysTime = t;  
-  nextSyncTime = t + syncInterval;
-  Status = timeSet; 
+  sysTime = (uint32_t)t;  
+  nextSyncTime = (uint32_t)t + syncInterval;
+  Status = timeSet;
   prevMillis = millis();  // restart counting from now (thanks to Korman for this fix)
 } 
 
-void  setTime(int hr,int min,int sec,int dy, int mnth, int yr){
+void setTime(int hr,int min,int sec,int dy, int mnth, int yr){
  // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
  //it is converted to years since 1970
   if( yr > 99)
@@ -288,11 +296,13 @@ void  setTime(int hr,int min,int sec,int
   setTime(makeTime(tm));
 }
 
-void adjustTime(long adjustment){
+void adjustTime(long adjustment) {
   sysTime += adjustment;
 }
 
-timeStatus_t timeStatus(){ // indicates if time has been set and recently synchronized
+// indicates if time has been set and recently synchronized
+timeStatus_t timeStatus() {
+  now(); // required to actually update the status
   return Status;
 }
 
@@ -303,5 +313,6 @@ void setSyncProvider( getExternalTime ge
 }
 
 void setSyncInterval(time_t interval){ // set the number of seconds between re-sync
-  syncInterval = interval;
-}
\ No newline at end of file
+  syncInterval = (uint32_t)interval;
+  nextSyncTime = sysTime + syncInterval;
+}
diff -rupN /Time/Time/Time.h /Time/Time/Time.h
--- /Time/Time/Time.h	2011-07-22 17:30:06.000000000 +0530
+++ /Time/Time/Time.h	2014-11-25 18:48:37.000000000 +0530
@@ -8,12 +8,29 @@
 */     
 
 #ifndef _Time_h
+#ifdef __cplusplus
 #define _Time_h
 
 #include <inttypes.h>
+#ifndef __AVR__
+#include <sys/types.h> // for __time_t_defined, but avr libc lacks sys/types.h
+#endif
 
+
+#if !defined(__time_t_defined) // avoid conflict with newlib or other posix libc
 typedef unsigned long time_t;
+#endif
+
 
+// This ugly hack allows us to define C++ overloaded functions, when included
+// from within an extern "C", as newlib's sys/stat.h does.  Actually it is
+// intended to include "time.h" from the C library (on ARM, but AVR does not
+// have that file at all).  On Mac and Windows, the compiler will find this
+// "Time.h" instead of the C library "time.h", so we may cause other weird
+// and unpredictable effects by conflicting with the C library header "time.h",
+// but at least this hack lets us define C++ functions as intended.  Hopefully
+// nothing too terrible will result from overriding the C library header?!
+extern "C++" {
 typedef enum {timeNotSet, timeNeedsSync, timeSet
 }  timeStatus_t ;
 
@@ -121,6 +138,7 @@ void    setSyncInterval(time_t interval)
 void breakTime(time_t time, tmElements_t &tm);  // break time_t into elements
 time_t makeTime(tmElements_t &tm);  // convert time elements into time_t
 
-
+} // extern "C++"
+#endif // __cplusplus
 #endif /* _Time_h */
 
Binary files /Time/Time/.Time.h.swp and /Time/Time/.Time.h.swp differ
diff -rupN /TimedAction/TimedAction.h /TimedAction/TimedAction.h
--- /TimedAction/TimedAction.h	2010-10-08 02:57:26.000000000 +0530
+++ /TimedAction/TimedAction.h	2014-12-16 19:55:41.427804271 +0530
@@ -30,7 +30,7 @@
 #ifndef TIMEDACTION_H
 #define TIMEDACTION_H
 
-#include "WProgram.h"
+#include "Arduino.h"
 
 #define NO_PREDELAY 0
 
@@ -67,4 +67,4 @@ class TimedAction {
 || | 1.1 2009-04-08 - Alexander Brevig : Added an example that demonstrates three arduino examples at once
 || | 1.0 2009-03-23 - Alexander Brevig : Initial Release
 || #
-*/
\ No newline at end of file
+*/
